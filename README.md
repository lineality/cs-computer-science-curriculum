
# Teaching CS Computer Science and Programming Curriculum: Outline, Suggestions, Examples, Notes 

#### This guide will walk through the process of designing a Computer Science study curriculum: 
- Overall Curriculum Design Items
- Strategies & Approaches
- Resources
- Computer Science Curriculum Content Specifics


# Approaches To Designing a "CS" Curriculum
## In this guide we will sample from all of the following approaches.

1. Follow curricula posted by established institutions:
http://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/ You could source a topic/skill list from this as a content map, and then source further instruction from online. 
Note: This will likely be shifted towards abstract principles (and away from practical implementation)
https://www.khanacademy.org/  tends to be very reliable.

2. Books (Tech Interview Approach):
Use "the standard technical interview" or "coding interview" as your guide to compiling a primary skill/ability list:
Note: This will likely be shifted towards practical programming (and way from abstract principle discussion). https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850

3. Books (Programing Languages Approach):
Some trends come and go in computer programming but a lot stays remarkably the same when it was well designed to begin with. In 1978 it was remarked ~"C wears well as one's experience with it grows." Forty years later this is still amazingly true. You can learn the entire C language in one small book and with it many core areas of programming. In addition, many later languages and conventions have been influenced by C, so understanding C will help you to understand all that C has influenced.  https://en.wikipedia.org/wiki/C_%28programming_language%29 & https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628 

4. Books (Algorithms and Algorithmics Textbooks Approach):
Pending list of good Algorithms books... 
Note: I strongly do NOT recommend this book as something to read because of the horrendous disorganization of the layout and outright incoherent style of writing (aimless vague half-off-topic run-on-sentences that can be interpreted in a dozen different ways), but this book does contain example problems to solve:
https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X 


5. Another approach is extensive use of free 'code challenge' and exam sites:
(The idea being that in the course of doing so you will discover a cross section of practical and theoretical topics.)
#### For Desktop:
- Leetcode https://leetcode.com/ 
- Edabyte https://edabit.com/
- Code Signal  https://app.codesignal.com/ 
- JetBrains https://hyperskill.org/curriculum
- Hackerrank https://www.hackerrank.com/challenges/ 
- Triplebyte https://triplebyte.com/

#### For Mobile:
- Sololearn https://www.sololearn.com/
- m1m0 https://getmimo.com/ 
- Grasshopper (Google) https://grasshopper.app/ 



# Curriculum Standards:
Regardless of the subject area of the course of study, there are best practice standards for what should be included in an effective curriculum.
1. A clear and comprehensive content-curriculum
2. Teaching method standards (see ISEP areas / SNES)
3. Content Maps per lesson/sub-unit
4. Team project modes
5. Story/Narrative based
6. Cumulative-Review
7. Student Progression Feedback Based
8. Pre, Post, Formative, Summative, Testing and separated instruction and certification
9. Privacy Conscious (student data)


# CS curricula commonly include these general areas: 
- Languages (Languages programming & scripting Languages): types, features, uses
- Programming: problem solving strategies, debugging, testing, functions, OOP vs Functional, etc.
- Data Structures
- Computer Architecture
- Algorithms & Time/Memory Complexity
- SCRUM software team project organization
- History of Computer Development


# History:
Two good accessible (for any reader) history of computers books are:
- https://www.amazon.com/Innovators-Hackers-Geniuses-Created-Revolution/dp/1476708703
- https://www.amazon.com/Information-History-Theory-Flood-ebook/dp/B004DEPHUC


# Curriculum Standards: An effective curriculum should be...
- Project Based (learn by doing, fail early and often)
- Narrative or Story Based
- Cumulative-Review Based
- Modular-Recombination Based
- Team-Work Based


# Elements of Programming:
## Programs & Functions
- MVP: Minimal Viable Products, "break down and build up" 
- Runtime, "optimization", and "Does it work"
- Edge Cases
- Workflow


## Files:
#### Files and Folders (directories) are a very important an often un-emphasized part of programing/coding/hacking. Being able to create, erase, modify, move, locate files (text files, scripts, etc) is a key area to be comfortable with. Python is especially handy for this.
- print
- create
- open
- change/modify
- save
- remote


## Directories:
- move
- create
- remove
- working directory
- reaching out of Current Working Directory
- searching/checking directories

## Characters Strings and Printing
- binary
- raw files
- print files
- unicode

# Languages
#### Types of Languages:
- static vs. dynamic
- compiled vs. interpreted
- high vs. low level
- lambda-calculus-functional
- Object Oriented
#### History of Programming Languages, languages still in use:
- https://en.wikipedia.org/wiki/History_of_programming_languages


## Operations (Types of Operations & Specific Operations)
- Logical operators: not,  and, or, nor, nand
- Math Operations: * ** / //(floor division) %(remainder) + - 
- Directory Operations: move
- File Operations: open close 
- String Operations: print, slice, 
- Data Structure Operations: slice, append, remove, add, pop, push, 
- Boolean Operations: True False: && | == is and not 
- Bitwise Operations: ^ & or
- Unpacking (as in Tuple Unpacking)
- Mutability: ability or inability to be changed
- Unary operators (takes a single operant) ! ~
- bitwise complement operator
https://en.wikipedia.org/wiki/Bitwise_operation#NOT 

## Decision Making & Computations
- if else elif
- while
- List Comprehensions
- switches
- breaking
- exiting
- nexting
- jumping
- Lambda Functions
- Booleans in Computations


## Data Types
#### https://github.com/lineality/teaching-cs-computer-science/blob/master/data_types_intro.md
- Examples of Types: int long short float char boolean 
- Automatic Type Detection:
- Strict or not-strict Typing:


## Basics to start with:
- files
- directories
- variables
- pathways
- indices
- keys
- values
- scripts and programs
- functions
- libraries
- operating systems


## Data Structures 1 (or Functional Concrete Data Types)
- Lists
- Trees
- Arrays


## Data Structures 2 (or Functional AbstractData Types)
- Stacks
- Queues
- Priority Queues
- Sets
- Tables
- Binary Search Trees
- AVL Trees (Adelson-Velskii and Landis) or Balanced Binary Search Trees
- Heaps


## Data Structures 3 
- Dictionaries
- Linked-lists
- Graphs
- Sets
- Tuples
- Streams
- Strings
- Blobs
- Flat "Serialized" Structures
- Hash Tables
- Maps (HashMaps, SortedMaps, TreeMaps, ListMaps)
- Sequences(Seq)

## Higher Level Structures, Features, and Techniques
- slicing
- zipping
- list/dict comprehensions

## "Lower" Level Structures, Features, and Techniques
- assembly language
- memory management
- pointers

## Bug Prevention & Best Practice
- preventative methods
- standards and policies (e.g. PEP8)
- linters
- formaters


## Reading & Writing Error Messages "Don't fail silently"
-

## Debugging Etc.
vsCode Debugger in Python, 4-Lesson-Course:
https://www.youtube.com/watch?v=KEdq7gC_RTA&list=PLQzZ4krxwT9Yay3kz8ly4wXiYJHzMtsWi
Debugging as "walking through the code step by step."


#### Content Map Skills for Debugging:
- software for debugging
- breakpoints
- traversing
- "current scope"
- step into vs. step out
- call stack
- variables: local vs. global
- the debugger-console
- inspecting 'state'


## Other Elements of Coding & Programing
- Time Complexity, Space Complexity, & 'Big O' Notation
- Recursion & Base Cases
- Objects
- Functions
- Lambda Functions
- Methods
- Vectors
- Tensors
- Matrices


## Algorithms
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/syllabus/
- Sorting
- Runtime
- Memory Costs
- Kendall tau distance
- permutation / ranking / set
- priority queue


## Code & Communication
####"How to write code? Communication with people is the most important thing." ~ Brian Doyle
- Verbal Practice (explain your code to your friends, pets, or plants)
- Explaining to others is part of understanding for yourself.
- Documentation in Code
- "Future You"
- Naming Variables
- Readable vs. Terse
- communication and tested code vs. 'uniqueness' and plagiarism fetishism
- Tradeoffs between clarity vs. other optimizations

## Coding as A Team or Distributed 'Project'
- SCRUM
- Schedules
- Goals
- Sustainability
- Advocacy
- Ownership

# On "Programing"
- "Programming" vs. "Computer Science": Depending on the course, Programing and  Computer-Science may be lumped together or taught separately or only one may be touched on. The distinction (if one is made) is often similar to the 'pure vs. applied' divide common throughout science and engineering, etc. 'Computer Science' is often pure ideas and ideals, concepts and principles. 'Programing' is often full of specific hardware-and-software skills and various practical considerations in doing projects in the real world.  
- Style:  The primary question and criteria for anything added to or done to a set of code is: How does this make the code easier to read, understand, and build on? If the addition or change does not help in any of those contexts, that is a red flag. There are people who aggressively attack readability, which is also a red flag. 
- Terminal & Bash
- Deployment (making products available to users)
- Tools (Text Editor, vs Word Processor; IDE; Notebooks) https://docs.google.com/document/d/1dZJI20D7uIknT1pdlTSmlHH1WPYdVhs2PSUyH1qdnUo/ 
- Interpreters, Compilers
- Managing 'Environments' (Docker, Pip)
- Workflow (Data Science workflow vs. WebDev workflow)
- Best Practice
- Practical Skills
- Managing Environments and Tools
- Policy and Goals:
- Schedules and "Iterative" feature deployment:  Agile, Scrum
- Working On A Team: Agile, Scrum
- Networks (setting up HTTPS, remote SSH)
- Security (passwords, encryption, social engineering, etc.)


# Work-Flow & Agile
- MVP: Minimum Viable Product = Simplest Thing That Works
- Cross Functional Teams of Generalists
- User Stories
- Standup
- Iteration
- Short Time Cycles


# TDD Test Driven Development
- Code Testing


# Continuous Integration 
- Dev branch & main branch
- testing based merging
- "releases"


# "upscaling" and monitoring
- best practice is for mentoring of junior staff to be explicitly required in jobs for all people
- 


# Continuous Delivery
- not letting features pile up before delivering to user


# Concepts:
- NP-completeness (Non-polynomial-time completeness)


# Other Areas:
- Networks
- Security
- Operating Systems
- Parallel Processing
- Functional Programming
- Quantum Computing
- systems design
- systems engineering

# Deployment
#### In various areas of computer programming from traditional programming to web development to data science, 'deployment' is a crucial area. 'Deployment' means all the formalities of getting 'the thing you made' to be actually used by the person who uses it. 
- compiled code
- 'mobile' OS programs (~SDK: android studio / ios)
- web apps (easy deploy platforms like heroku)
- ~SDK tools like 'Unity'
- share-able, run-able, code "notebooks" 
- "Dashboards" and code user interfaces

# Job Specialization Areas (for portfolio, projects, and job applications):
- Coding For specialized hardware (Robotics)
- General Software Engineering
- Web Dev
- Mobile 
- Wearable 
- IoT (Internet of Things)
- Security
- Big Data Software Engineering
- Network Architecture Software Engineering
- Domain/Sector Specific
	- Biomedical/Health
	- Legal
	- Aerospace
	- Defense


## More Books
- Clean Code by Robert Martin
- Clean Architecture by Robert Martin
- Design Patterns by the gang of four
- Algorithms A Functional Programming Approach (Haskel) by Fethi Rabhi and Guy Lapalme

# Imperative vs. Functional Languages

# Compilers vs. Interpreters

# The Era of Object Oriented Programming in Hindsight

# Sample Starting Point / Starting Lesson

## Recommended First Language: Python

A Colab as a template for first lesson notes:
https://colab.research.google.com/drive/1dJFunMg6wT-ht8TQ5xpo3PNrnvDkjlhx?usp=sharing

## Main Tools:
- Editor (Text editor, ~ IDE, IDK, like Word Processor)
- Terminal (Command Prompt, Shell, ~Bash)
- Notebook (Jyputer, Colab)

## Environments & Containers:
- local or online
- virtual environments
- containers (docker) 

## Refactoring vs. Optimizing vs. Feature Improvements
- https://www.thoughtworks.com/books/refactoring2 (video)
- refactoring is making code easier to understand
- refactoring is ongoing
- not everyone uses this definition
- readability
- change-ability
- entensiblity 

## Collaborative Coding

## Terminology:
- coding
- hacking
- scripting
- programming

## workflow & workflow variations
- Low level programming
- High level programming
- Analytics (e.g. business analytics)
- Data Science Workflow
- Deep learning Workflow

## Project Management & Organization
- Agile
- Scrum
- Sig Sigma

## Tools & Devices for Writing Programs
- command line terminal
- notebook
- SDK
- IDE
- IDK
- "Text Editor"
- linter 
- formater
- debugger


## Code Challenge Websites: (Try them all)
- Edabit https://edabit.com/ https://edabit.com/challenges/python3 
- Code Signal https://app.codesignal.com/ 
- Leet Code https://leetcode.com/ 
- Hacker Rank https://www.hackerrank.com/ 

### S.U.P.E.R. Problem Solving Framework
For solving problems that either at first seem too difficult to solve or problems that seemed easy at first but became difficult and confusing (for example, due to incomplete or incorrect instructions, as often happens on 'code challenge' websites), S.U.P.E.R. is one among many synonymous acronym frameworks for using best practice to systematically break down and solve a problem, cutting through other confusions, distractions, etc. 

```
S.U.P.E.R.

S -> Stop, Focus, Take a deep breath
U -> Understand the problem, read all the documentation, look at example inputs and outputs, examine code tests, look at edge case policies, etc. Know exactly what is needed.
P -> Plan (pseudocode) Before starting to write your actual code, make a flow-chart and or pseudo-code outline, often running through a few examples to trace through how the process works
E -> Execute, MVP; Start with a minimal working version/vision, test constantly as you work through each part, 
R -> Reflect / Revise / Reiterate / Recurse / Review / Compare; talk to other people, get feedback on alternative solutions, figure out what could be done better; identify tradeoffs and debates, though you may be correct in your case. 
```

# Begin! (Example Starting Activity)

## Open Two Browser Windows: develope in notebook, submit to site
- https://edabit.com/challenges/python3 
- https://colab.research.google.com


## Best Practice Coding Template



```
# Name, Date, Title
#
# Problem (User's Problem)
# You Have: (What input do you start with: What does the user have?)
# You Need: (output: what does the user need)
# You Must: (requirement such as how many outputs, 
#            formatting, data types, specific edge cases)
# Example input / output:
#
# Solution (Product / Feature)
# Edge Cases Etc:
#
# Revision, Reflection, Future Versions, Action Items:
#
# I Learned: (e.g. Compare to other solutions)
# 
#
# YOUR CODE HERE

def my_function(input_1):
   pass
 
# Time Test
import time
start = time.time()
 
# Run Code Here...
print(my_function("input"))
print ("Run Time = ", time.time()-start)
 
```

# Doc Version of this File
https://docs.google.com/document/d/1LrrgYk1i4Dze6FXSLx4zlRMP6ToDqDXFNrmOlWhlmWc/edit?usp=sharing
