
# Teaching CS Computer Science and Programming: Outline, Curriculum, Notes, Suggestions, Examples


# Doc Version
https://docs.google.com/document/d/1LrrgYk1i4Dze6FXSLx4zlRMP6ToDqDXFNrmOlWhlmWc/edit?usp=sharing

This guide will walk through the process of designing a Computer Science study curriculum. 


# Approaches To Designing a "CS" Curriculum
1. Follow curricula posted by established institutions:
http://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/ You could source a topic/skill list from this as a content map, and then source further instruction from online. 
Note: This will likely be shifted towards abstract principles (and away from practical implementation)
https://www.khanacademy.org/  tends to be very reliable.

2. Use "the standard technical interview" or "coding interview" as your guide to compiling a primary skill/ability list:
Note: This will likely be shifted towards practical programming (and way from abstract principle discussion). https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850

3. Another approach is extensive use of free code challenge and exam sites:
(The idea being that in the course of doing so you will discover a cross section of practical and theoretical topics.)
- Leetcode https://leetcode.com/ 
- Edabyte https://edabit.com/
- Code Signal  https://app.codesignal.com/ 
- JetBrains https://hyperskill.org/curriculum
- Hackerrank https://www.hackerrank.com/challenges/ 
- Triplebyte https://triplebyte.com/

Mobile:
- Sololearn https://www.sololearn.com/
- m1m0 https://getmimo.com/ 
- Grasshopper (Google) https://grasshopper.app/ 

In this guide we will sample from all of the above approaches.


# Curriculum Standards:
Regardless of the subject area of the course of study, there are best practice standards for what should be included in an effective curriculum.
1. A clear and comprehensive content-curriculum
2. Teaching method standards (see ISEP areas / SNES)
3. Content Maps per lesson/sub-unit
4. Team project modes
5. Story/Narrative based
6. Cumulative-Review
7. Student Progression Feedback Based
8. Pre, Post, Formative, Summative, Testing and separated instruction and certification
9. Privacy Conscious


# CS curricula commonly include these general areas: 
- Languages (Languages programming & scripting Languages): types, features, uses
- Programming: problem solving strategies, debugging, testing, functions, OOP vs Functional, etc.
- Data Structures
- Computer Architecture
- Algorithms & Time/Memory Complexity
- SCRUM software team project organization
- History of Computer Development


# History:
Two good accessible (for any reader) history of computers books are:
- https://www.amazon.com/Innovators-Hackers-Geniuses-Created-Revolution/dp/1476708703
- https://www.amazon.com/Information-History-Theory-Flood-ebook/dp/B004DEPHUC


# Curriculum Standards: An effective curriculum should be...
- Project Based (learn by doing, fail early and often)
- Narrative or Story Based
- Cumulative-Review Based
- Modular-Recombination Based
- Team-Work Based


# Elements of Programming:
## Programs & Functions
- MVP: Minimal Viable Products, "break down and build up" 
- Runtime, "optimization", and "Does it work"
- Edge Cases
- Workflow


## Files:
- print
- create
- open
- change/modify
- save
- remote

## Directories:
- move
- create
- remove
- working directory
- reaching out of Current Working Directory
- searching/checking directories

## Characters Strings and Printing
- binary
- raw files
- print files
- unicode

# Languages
#### Types of Languages:
- static vs. dynamic
- compiled vs. interpreted
- high vs. low level
- lambda-calculus-functional
- Object Oriented
#### History of Programming Languages, languages still in use:
- https://en.wikipedia.org/wiki/History_of_programming_languages


## Operations (Types of Operations & Specific Operations)
- Logical operators: not,  and, or, nor, nand
- Math Operations: * ** / //(floor division) %(remainder) + - 
- Directory Operations: move
- File Operations: open close 
- String Operations: print, slice, 
- Data Structure Operations: slice, append, remove, add, pop, push, 
- Boolean Operations: True False: && | == is and not 
- Bitwise Operations: ^ & or
- Unpacking (as in Tuple Unpacking)
- Mutability: ability or inability to be changed
- Unary operators (takes a single operant) ! ~
- bitwise complement operator
https://en.wikipedia.org/wiki/Bitwise_operation#NOT 

## Decision Making & Computations
- if else elif
- while
- List Comprehensions
- switches
- breaking
- exiting
- nexting
- jumping
- Lambda Functions
- Booleans in Computations


## Data Types
- Examples of Types: int long short float char boolean 
- Automatic Type Detection:
- Strict or not-strict Typing:


## Data Structures
- Lists/Arrays
- Dictionaries
- Linked-lists
- Heaps
- Graphs
- Trees
- Sets
- Tuples
- Streams
- Queues
- Strings
- Stacks
- Blobs
- Flat "Serialized" Structures
- Hash Tables
- Graphs
- Sets 
- Maps (HashMaps, SortedMaps, TreeMaps, ListMaps)
- Sequences(Seq)


## Bug Prevention & Best Practice
- preventative methods
- standards and policies (e.g. PEP8)
- linters
- formaters


## Debugging Etc.
vsCode Debugger in Python, 4-Lesson-Course:
https://www.youtube.com/watch?v=KEdq7gC_RTA&list=PLQzZ4krxwT9Yay3kz8ly4wXiYJHzMtsWi
Debugging as "walking through the code step by step."


#### Content Map Skills for Debugging:
- breakpoints
- traversing
- "current scope"
- step into vs. step out
- call stack
- variables: local vs. global
- the debugger-console
- inspecting 'state'


## Other Elements of Coding & Programing
- Time Complexity, Space Complexity, & 'Big O' Notation
- Recursion & Base Cases
- Objects
- Functions
- Lambda Functions
- Methods
- Vectors
- Tensors
- Matrices


## Algorithms
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/syllabus/
- Sorting
- Runtime
- Memory Costs


## Code & Communication
####"How to write code? Communication with people is the most important thing." ~ Brian Doyle
- Verbal Practice (explain your code to your friends, pets, or plants)
- Explaining to others is part of understanding for yourself.
- Documentation in Code
- "Future You"
- Naming Variables
- Readable vs. Terse
- communication and tested code vs. 'uniqueness' and plagiarism fetishism
- Tradeoffs between clarity vs. other optimizations

## Coding as A Team or Distributed 'Project'
- SCRUM
- Schedules
- Goals
- Sustainability
- Advocacy
- Ownership

# On "Programing"
- "Programming" vs. "Computer Science": Depending on the course, Programing and  Computer-Science may be lumped together or taught separately or only one may be touched on. The distinction (if one is made) is often similar to the 'pure vs. applied' divide common throughout science and engineering, etc. 'Computer Science' is often pure ideas and ideals, concepts and principles. 'Programing' is often full of specific hardware-and-software skills and various practical considerations in doing projects in the real world.  
- Style:  The primary question and criteria for anything added to or done to a set of code is: How does this make the code easier to read, understand, and build on? If the addition or change does not help in any of those contexts, that is a red flag. There are people who aggressively attack readability, which is also a red flag. 
- Terminal & Bash
- Deployment (making products available to users)
- Tools (Text Editor, vs Word Processor; IDE; Notebooks) https://docs.google.com/document/d/1dZJI20D7uIknT1pdlTSmlHH1WPYdVhs2PSUyH1qdnUo/ 
- Interpreters, Compilers
- Managing 'Environments' (Docker, Pip)
- Workflow (Data Science workflow vs. WebDev workflow)
- Best Practice
- Practical Skills
- Managing Environments and Tools
- Policy and Goals:
- Schedules and "Iterative" feature deployment:  Agile, Scrum
- Working On A Team: Agile, Scrum
- Networks (setting up HTTPS, remote SSH)
- Security (passwords, encryption, social engineering, etc.)



# Concepts:
- NP-completeness (Non-polynomial-time completeness)

# Other Areas:
- Networks
- Security
- Operating Systems
- Parallel Processing
- Functional Programming
- Quantum Computing
- systems design
- systems engineering


# Job Specialization Areas (for portfolio, projects, and job applications):
- Coding For specialized hardware (Robotics)
- General Software Engineering
- Web Dev
- Mobile 
- Wearable 
- IoT (Internet of Things)
- Security
- Big Data Software Engineering
- Network Architecture Software Engineering
- Domain/Sector Specific
	- Biomedical/Health
	- Legal
	- Aerospace
	- Defense


## Books
- Clean Code by Robert Martin
- Clean Architecture by Robert Martin
- Design Patterns by the gang of four



# Sample Starting Point / Starting Lesson

## Recommended First Language: Python

A Colab as a template for first lesson notes:
https://colab.research.google.com/drive/1dJFunMg6wT-ht8TQ5xpo3PNrnvDkjlhx?usp=sharing

## Main Tools:
- Editor (Text editor, ~ IDE, IDK, like Word Processor)
- Terminal (Command Prompt, Shell, ~Bash)
- Notebook (Jyputer, Colab)

## Environment:
- local or online
- linter, formater
- virtual/container

## Code Challenge Websites: (Try them all)
- Edabit https://edabit.com/ https://edabit.com/challenges/python3 
- Code Signal https://app.codesignal.com/ 
- Leet Code https://leetcode.com/ 
- Hacker Rank https://www.hackerrank.com/ 

### S.U.P.E.R. Problem Solving Framework
For solving problems that either at first seem too difficult to solve or problems that seemed easy at first but became difficult and confusing (for example, due to incomplete or incorrect instructions, as often happens on 'code challenge' websites), S.U.P.E.R. is one among many synonymous acronym frameworks for using best practice to systematically break down and solve a problem, cutting through other confusions, distractions, etc. 

```
S.U.P.E.R.

S -> Stop, Focus, Take a deep breath
U -> Understand the problem, read all the documentation, look at example inputs and outputs, examine code tests, look at edge case policies, etc. Know exactly what is needed.
P -> Plan (pseudocode) Before starting to write your actual code, make a flow-chart and or pseudo-code outline, often running through a few examples to trace through how the process works
E -> Execute, MVP; Start with a minimal working version/vision, test constantly as you work through each part, 
R -> Reflect / Revise / Reiterate / Recurse / Review / Compare; talk to other people, get feedback on alternative solutions, figure out what could be done better; identify tradeoffs and debates, though you may be correct in your case. 
```

# Begin! (Example Starting Activity)

## Open Two Browser Windows: develope in notebook, submit to site
- https://edabit.com/challenges/python3 
- https://colab.research.google.com


## Best Practice Coding Template



```
# Name, Date, Title
#
# Problem (User's Problem)
# You Have: (What input do you start with: What does the user have?)
# You Need: (output: what does the user need)
# You Must: (requirement such as how many outputs, 
#            formatting, data types, specific edge cases)
#
# Example input / output:
#
# Solution (Product / Feature)
# 
# Edge Cases Etc:
#
# Revision, Reflection, Future Versions, Action Items:
# I Learned: (Compare to other solutions)
# 
#
# YOUR CODE HERE

# Time Test
import time
start = time.time()
# Run Code Here...
print(function_name("input"))
print ("Run Time = ", time.time()-start)
 
```
